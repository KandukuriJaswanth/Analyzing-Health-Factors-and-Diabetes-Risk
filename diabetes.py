# -*- coding: utf-8 -*-
"""diabetes.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QwVBU4z7iCVv8acPNEoXFsGxxnsC91bH
"""

pip install ydata-profiling

import seaborn as sns
import numpy as np
import pandas as pd
from matplotlib import pyplot as plt
from ydata_profiling import ProfileReport

from google.colab import drive
drive.mount('/content/drive')

"""**Project Overview**  
The objective of this project is to develop a predictive model to estimate the likelihood of diabetes based on health-related features in the dataset. The process includes the following steps:  

1. **Data Exploration**: Analyze the dataset to understand its structure, key features, and the target variable.  
2. **Data Preprocessing**: Prepare the data by cleaning it, handling missing values and outliers, and applying normalization techniques.  
3. **Feature Engineering**: Identify and select the most significant features that contribute to accurate predictions.  
4. **Model Development**: Utilize Python libraries like Scikit-Learn to build machine learning models.  
5. **Model Evaluation**: Measure the model's performance using metrics such as accuracy, precision, recall, and F1 score.

# **Data Overview**
"""

# Import the Daibebets dataset from the specified CSV file using Pandas
df1 = pd.read_csv('/content/drive/MyDrive/diabetes_012_health_indicators_BRFSS2015.csv')
df1

"""# **Basic Metrics**"""

# Checking Shape of data
df1.shape

# Columns in data
df1.columns

# Overview of the dataset structure
df1.info()

""" # **Data Cleaning**

"""

# Check for missing or null values in the diabetes dataset and count them for each column
df1.isna().sum()

df1.groupby('Diabetes_012').apply(lambda x: x.count())

"""# **Descriptive Statistics**"""

# Summary statistics for numerical columns
df1.describe(include = 'all').T

# Select numeric columns from the dataset
numeric_cols = df1.select_dtypes(include=['number']).columns
print("Numeric columns in the dataset:")
print(numeric_cols)

# Variance measures how much the data is spread out from the mean.
variance_values = df1[numeric_cols].var()
print("\nVariance for each numeric column:")
variance_values

# Covariance measures how two variables move together. Positive covariance indicates that the variables tend to move in the same direction.
covariance_matrix = df1[numeric_cols].cov()
print("\nCovariance matrix:")
covariance_matrix

# Correlation measures the strength and direction of the relationship between two variables. It ranges from -1 (perfect negative correlation) to +1 (perfect positive correlation).
correlation_table = df1[numeric_cols].corr()
print("\nCorrelation table:")
correlation_table

# Mode is the value that appears most frequently in a dataset.
mode_values = df1.mode().iloc[0]  # Using iloc[0] to get the mode for each column
print("Mode for each column:")
mode_values

# Range is the difference between the maximum and minimum values in a dataset.
range_values = df1[numeric_cols].max() - df1[numeric_cols].min()
print("\nRange for each numeric column:")
range_values

# Range is the difference between the maximum and minimum values in a dataset.
range_values = df1[numeric_cols].max() - df1[numeric_cols].min()
print("\nRange for each numeric column:")
range_values

# Convert any potential strings in numeric columns to NaN (if they exist)
df[numeric_cols] = df1[numeric_cols].apply(pd.to_numeric, errors='coerce')
Q1 = df1[numeric_cols].quantile(0.25)
Q3 = df1[numeric_cols].quantile(0.75)
IQR = Q3 - Q1
print("\nInterquartile Range (IQR) for each numeric column:")
IQR

# Detecting outliers based on IQR
outliers = df1[((df1[numeric_cols] < (Q1 - 1.5 * IQR)) | (df1[numeric_cols] > (Q3 + 1.5 * IQR))).any(axis=1)]
print("Outliers:", outliers)

outliers

"""# **Data Visualization**"""

# 1. Diabetes Status by Age Group
plt.figure(figsize=(10, 6))
sns.barplot(x='Age', y='Diabetes_012', data=df1, estimator=lambda x: sum(x == 2)/len(x), palette='Blues')
plt.title('Proportion of Diabetes (Status = 2) by Age Group', fontsize=16)
plt.xlabel('Age Groups', fontsize=12)
plt.ylabel('Proportion with Diabetes', fontsize=12)
plt.xticks(rotation=45)
plt.show()

# 2. Diabetes Status by Education Level
plt.figure(figsize=(10, 6))
sns.barplot(x='Education', y='Diabetes_012', data=df1, estimator=lambda x: sum(x == 2)/len(x), palette='Purples')
plt.title('Proportion of Diabetes (Status = 2) by Education Level', fontsize=16)
plt.xlabel('Education Level', fontsize=12)
plt.ylabel('Proportion with Diabetes', fontsize=12)
plt.show()

# 3. Diabetes Status by Income Level
plt.figure(figsize=(10, 6))
sns.barplot(x='Income', y='Diabetes_012', data=df1, estimator=lambda x: sum(x == 2)/len(x), palette='Greens')
plt.title('Proportion of Diabetes (Status = 2) by Income Level', fontsize=16)
plt.xlabel('Income Level', fontsize=12)
plt.ylabel('Proportion with Diabetes', fontsize=12)
plt.show()

# 4. Diabetes and Multiple Health Issues (HighBP, HighChol, Stroke, HeartDiseaseorAttack)
df1['HealthIssuesCount'] = df1[['HighBP', 'HighChol', 'Stroke', 'HeartDiseaseorAttack']].sum(axis=1)

plt.figure(figsize=(10, 6))
sns.boxplot(x='Diabetes_012', y='HealthIssuesCount', data=df1, palette='coolwarm')
plt.title('Number of Health Issues by Diabetes Status', fontsize=16)
plt.xlabel('Diabetes Status', fontsize=12)
plt.ylabel('Number of Health Issues', fontsize=12)
plt.show()

# 1. Calculate the correlation matrix for numeric columns
correlation_matrix = df1.corr()
# 2. Display the correlation matrix as a heatmap
plt.figure(figsize=(12, 10))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt='.2f', cbar=True, square=True)
plt.title('Correlation Matrix of Numeric Features', fontsize=16)
plt.show()

"""# **Report**"""

# Generating a profile report for the healthcare dataset
profile = ProfileReport(df1, title="Diabetes Dataset Report")
# Saving the profile report to an HTML file
profile.to_file('Diabetes Dataset Report.html')

"""# Key points**
### Key Points for Correlation Matrix Analysis  

1. **Correlation Calculation**: Evaluates the linear relationship between numeric variables, with values ranging from -1 (strong negative) to +1 (strong positive).  
2. **Heatmap Visualization**: Provides a visual representation of correlations, making it easier to identify significant relationships.  
3. **Positive Correlations**: Features like high BMI and physical inactivity often show a strong positive correlation with an increased risk of diabetes.  
4. **Negative Correlations**: Physical activity tends to exhibit a negative correlation with diabetes, suggesting that healthier lifestyle choices may reduce the risk.  
5. **Data Insights**: Highlights variable redundancies and identifies critical features for further analysis or predictive modeling.

# **Conclusion**
The code calculates the correlation matrix for numeric features, visualizes it with a heatmap, and identifies relationships like BMI's strong correlation with diabetes. It helps understand how variables like age, physical activity, and health conditions relate to diabetes risk.
"""

